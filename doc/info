variables globales:
{
	g_fd_ou/in/erreur 		: globale pour sortie d'erreur/ sortie & entree standard
	g_cmd_ret 				: variable de retour d'une commande
	g_errno					: simulateur de la variable errno
	g_sig_msg				:
	g_spec_char 			:
	g_sh_error 				: variable de gestion d'erreur 												?
	g_sh_struct				: variable globale de travail pour chaque boucle
}

DEFINE:
{
	PRC_NB 					:
	NB_ERR 					:
	SCHAR_NB 				:
	NB_SIG					:
	MAX_CMD_NAME			:
	PRC_LEN					:
}		

structures
{
	t_sh					:
	{
		structure "input" 	: donnees d'entree
		structure "proc"	: liste des builds-ins
		structure "cmdenv"	: donnees d'environnement
		structure "t_local"	: sert a faire des comparaisons
		current directory	: ted
		previous directory	: ted
	}

	t_in "input"			:
	{
		var "*user_in"		: la chaine d'entree
		var "**split_in"	: les chaines de commandes
		list "input_list"	:
		list "history"		: l'historique des commande
		tab cmd_list		:
	}

	t_prc "proc"			: structure de build_in
	{
		var "**proc_tab" 	:
		func "prc_func"		: pointeur vers fonction;
		int "proc_id"		: id correspondant de la fonction
	}

	
	t_shenv "cmdenv"		: donnees d'environnement
	{
		var "*cur_dir"		: current directory;
		tab "**bin_path"	: le PATH split:
		list "*env_list"	:
		tab "**env_tab"     : copie de **environ;
	}

	t_local	"local"			: pour comparaison
	{
		var "*name"			: un nom
		var "*val"			: une valeur
		t_bool				: un 1 ou un 0 ^^
	}

	t_sherror				: tableau contenant le erruer selon le ret
	{
		var err_str			: contient la chaine de caractere d'etteur; ? pourquoi taille de 100 ?
		var errno 			: et sa variable ici. 
	}

	t_schar					: 
	{

	}

	t_sighand : gerer les erreurs SIG
	{

	}
}

Generale;
	-> ajouter les static devant les fonctions;
	-> clarifier les headers
	-> eviter les variables globales dans la mesure du possible
	-> les espaces/ tabulations dans la ligne de commande ne sont pas géré
	-> il faut d'abord essayer d'executer av[0] ( en gerant les espaces) avant de chercher à trouver son executable 

Makefile:
	-> virer les *.c si on laisse dans l'etat.
	-> stucturer les fichiers

global_struct.c:
	-> kek ?


main.c :
	-> faire une fonciton d'initialisation globales && sh_env
	-> gerer le cas env -i pour le clear :

sighandler :
	-> ajouter les autres signaux
	-> gerer ctrl +D : end of file

exec_sh : (t_sh && env)																						?
	-> realiser une fonction d'initialisation sh_env (qui evite la redondance avec le main)
	-> dans la boucle while : realiser une fonction d'initialisation ( ou transfert vers get_input )
	-> dans l'ideal 3 blocs:  init / act / end

fork_process : regler le prototype "sh_env"				 													?
	-> ajouter
		if ((WIFSIGNALED(status)))
			sighandler(WTERMSIG(status));
	-> gerer le shlvl

get_input :
	-> voir si on ne peut pas free la variable static du get_next_line
	-> arg_index : faire qqchose avec ?

flush_sh_env :
	->

exec_cmd :
	->

exit_error :
	->

lexer-parser				:
job-control					:
termcaps					:
redirection					:
build-in bonus				:
gestion des scripts shell	:
autocompletion 				:
history						:













